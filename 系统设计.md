## 不停机数据迁移方案

双写迁移

1. 改造代码，数据写入时，同时写入旧库和新库
2. 读旧库数据到新库
3. 新旧数据库数据校验

## 微信朋友圈设计

## 微信抢红包设计

## 如何设计一个秒杀活动商品抢购服务

-  问题一：服务只能承载5万的QPS，但是现在面临的流量是50万QPS，在不扩容的情况下，如何做
- 问题二：如何保证商品被抢购的实际数量准确，先抢先得
- 问题三：由于下单之后付款需要调订单、支付等，如何保证前端用户的快速响应且结果准确，不能出现用户下单成功但是交易失败的场景
- 问题四：如果给用户返回抢购成功结果了，但是在调下游订单的时候失败了，应该如何做(分布式事务)

## 服务限流

## 秒杀系统设计

**问题1**：瞬时高并发：正常情况下，大部分用户会收到商品已经抢完的提醒，收到该提醒后，他们大概率不会在那个活动页面停留了，如此一来，用户并发量又会急剧下降。所以这个峰值持续的时间其实是非常短的，这样就会出现瞬时高并发的情况

**解决方法**：

1. 页面静态化：对活动页面做**静态化**处理。用户浏览商品等常规操作，并不会请求到服务端。只有到了秒杀时间点，并且用户主动点了秒杀按钮才允许访问服务端。
2. 使用CDN:即内容分发网络,使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。
3. 按钮置灰：大部分用户怕错过秒杀时间点，一般会提前进入活动页面。此时看到的秒杀按钮是置灰，不可点击的。只有到了秒杀时间点那一时刻，秒杀按钮才会自动点亮，变成可点击的。
   - 通过js脚本控制静态页面在秒杀时间时置亮
   - 前端可以加一个定时器，控制比如：10秒之内，只允许发起一次请求。如果用户点击了一次秒杀按钮，则在10秒之内置灰，不允许再次点击，等到过了时间限制，又允许重新点击该按钮。

**问题2：**缓存问题：在秒杀的过程中，系统一般会先查一下库存是否足够，如果足够才允许下单，写数据库。如果不够，则直接返回该商品已经抢完。由于大量用户抢少量商品，只有极少部分用户能够抢成功，所以绝大部分用户在秒杀时，库存其实是不足的，系统会直接返回该商品已经抢完。这是非常典型的：读多写少的场景。

**解决方法：**

1. 使用redis缓存：使用户先查询缓存，如果缓存中库存不足，则直接返回，如果库存足够，则进行写数据库

2. 加分布式锁：为了处理缓存击穿问题。即缓存中没有商品数据，同一时间大量请求同时访问数据库。也可以提前预热，将商品信息提前放到缓存中

   ![image-20220514045509554](C:\Users\fqh0722\AppData\Roaming\Typora\typora-user-images\image-20220514045509554.png)

3. 加布隆过滤器：为了处理缓存穿透问题。即缓存和数据库中都没有商品信息。也可以把不存在的商品信息放在缓存中，设置特殊的值表示商品不存在

**问题3**：库存问题：下单流程中还需要考虑用户下单后没有支付的问题。所以这里引出一个预扣库存的概念，那么秒杀商品的流程是：

1. 用户选择商品秒杀
2. 预扣库存 - 1
3. 用户支付
4. 如果用户支付在规定时间内成功，则进行下单。如果失败，则需要回退库存 + 1

除了预扣库存，回退库存问题，还有库存不足和库存超卖问题

**解决方法：**

使用lua脚本，保证扣减库存的原子性。

1. 先判断商品id是否存在，如果不存在则直接返回。
2. 获取该商品id的库存，判断库存如果是-1，则直接返回，表示不限制库存。
3. 如果库存大于0，则扣减库存。
4. 如果库存等于0，是直接返回，表示库存不足。

**问题4：**消息队列问题：秒杀场景与下单支付场景的并发量不同，需要用消息队列将秒杀与下单支付解耦。因此涉及到消息队列的异常处理

**解决方法：**

1. 消息丢失问题：在生产者发送mq消息之前，**先把该条消息写入消息发送表**，初始状态是待处理，然后再发送mq消息。消费者消费消息时，处理完业务逻辑之后，再**回调生产者的一个接口，修改消息状态为已处理**。如果生产者把消息写入消息发送表之后，再发送mq消息到mq服务端的过程中失败了，造成了消息丢失。用定时任务每隔一段时间去查询消息发送表中状态为待处理的数据，然后重新发送mq消息。
2. 消息重复消费问题：消费者读到消息之后，先判断一下**消息处理表**，是否存在该消息，如果存在，表示是重复消费，则直接返回。如果不存在，则进行下单操作，接着将该消息写入消息处理表中，再返回。下单和写消息处理表，要放在同一个事务中，保证原子操作。
3. 垃圾消息问题：如果出现了消息消费失败的情况。比如：由于某些原因，**消息消费者下单一直失败，一直不能回调状态变更接口**，这样job会不停的重试发消息。最后，会产生大量的垃圾消息。每次在job重试时，需要先**判断一下消息发送表中该消息的发送次数**是否达到最大限制，如果达到了，则直接返回。如果没有达到，则将次数加1，然后发送消息。这样如果出现异常，只会产生少量的垃圾消息，不会影响到正常的业务。
4. 延迟消费问题：通常情况下，如果用户秒杀成功了，下单之后，在15分钟之内还未完成支付的话，该订单会被自动取消，回退库存。可以使用**延迟队列**实现这个功能。下单时消息生产者会先生成订单，此时状态为待支付，然后会向延迟队列中发一条消息。达到了延迟时间，消息消费者读取消息之后，会查询该订单的状态是否为待支付。如果是待支付状态，则会更新订单状态为取消状态。如果不是待支付状态，说明该订单已经支付过了，则直接返回。用户完成支付之后，会修改订单状态为已支付

**问题5**：限流问题：黑客可能在自己的服务器上，模拟正常用户登录系统，跳过秒杀页面，直接调用秒杀接口。一秒钟可以请求成上千接口。如果不做任何限制，绝大部分商品可能是被机器抢到，而非正常的用户。所以，我们有必要识别这些非法请求，做一些限制。

**解决方法：**

1. 加验证码：用户在请求之前，需要先输入验证码。用户发起请求之后，服务端会去校验该验证码是否正确。只有正确才允许进行下一步操作，否则直接返回，并且提示验证码错误。普通验证码，由于生成的数字或者图案比较简单，可能会被破解。优点是生成速度比较快，缺点是有安全隐患。还有一个验证码叫做：`移动滑块`，它生成速度比较慢，但比较安全，是目前各大互联网公司的首选