## 索引

### **B树**

![image-20220413152204937](C:\Users\fqh0722\AppData\Roaming\Typora\typora-user-images\image-20220413152204937.png)

### B+树

- 非叶子节点不存储data, 只存储索引
- 叶子节点包含所有索引字段
- 叶子节点用指针连接
- 每一个节点大小为16kb, 每一个节点中的关键字占8Byte, 分支指针占6Byte, 所以每一个节点最多可以放1170个关键字，一张表大约可存放2千万条记录
- InnoDB的表数据文件本身就是按B+树组织的一个索引结构文件。所以InnoDB表必须建立主键，因为主键索引的叶子节点会保存数据，可以将索引和数据组织在一起

![image-20220413152004835](C:\Users\fqh0722\AppData\Roaming\Typora\typora-user-images\image-20220413152004835.png)

### B+树索引和Hash索引的区别

- Hash索引不支持范围查询
- Hash索引存在哈希碰撞问题

### 主键索引

- 叶子节点包含完整的数据记录

![image-20220413152445244](C:\Users\fqh0722\AppData\Roaming\Typora\typora-user-images\image-20220413152445244.png)

### 非主键索引

- 叶子节点存储主键值

![image-20220413152540708](C:\Users\fqh0722\AppData\Roaming\Typora\typora-user-images\image-20220413152540708.png)

### 前缀索引

使用字段的前几个字符建立索引

### 最左前缀原则

- 在检索数据时，mysql会一直向右匹配直到遇到范围查询 (>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整
- =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式 

### 覆盖索引

当sql语句的所求查询字段（select列）和查询条件字段（where子句）全都包含在一个索引中，可以直接使用索引查询而不需要回表。这就是覆盖索引

### 索引下推

不使用索引下推时：在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件。即拿到数据之后再做过滤

使用索引下推时：如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。即再拿数据的过程中做过滤

在某些场景下，可以大大减少回表次数，从而提升整体性能。

### 索引设计原则

1. 使用区分度高的字段作为索引
2. 使用短索引
3. 索引不是越多越好
4. 利用最左前缀原则

### 索引失效

1. 对于组合索引，不使用最左边的字段
2. 已%开头的like查询
3. 判断索引列不等于某个值
4. 对索引列进行运算
5. 查询条件使用or连接

### MyISAM和Innodb的区别

1. MyISAM只支持表级锁。Innodb支持行级锁和表级锁，默认是行级锁
2. MyISAM不支持事务。Innodb支持事务
3. MyISAM不支持聚集索引。Innodb支持聚集索引
4. MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据

## 事务

### 事务的四大特性

**原子性(Atomicity)** ：事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。 

**一致性(Consistent)** ：在事务开始和完成时,数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改,以保持数据的完整性。 

**隔离性(Isolation) ：**数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独 立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。 

**持久性(Durable)** ：事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。

### 并发事务处理带来的问题

脏读：事务A读取到了事务B已经修改但尚未提交的数据，不符合一致性要求

不可重复读：事务A内部的相同查询语句在不同时刻读出的结果不一致，不符合隔离性要求

幻读：事务A读取到了事务B提交的新增数据，不符合隔离性

### 事务隔离级别

- 事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性

![image-20220413163106454](C:\Users\fqh0722\AppData\Roaming\Typora\typora-user-images\image-20220413163106454.png)

## 锁

### **锁分类** 

从性能上分为**乐观锁**(用版本对比来实现)和**悲观锁** 

从对数据库操作的类型分，分为**读锁**和**写锁**(都属于悲观锁) 

读锁（**共享锁**，S锁(**S**hared)）：针对同一份数据，多个读操作可以同时进行而不会互相影响 ，会阻断写锁

写锁（**排它锁**，X锁(e**X**clusive)）：当前写操作没有完成前，它会阻断其他写锁和读锁 

从对数据操作的粒度分，分为**表锁**和**行锁** 

间隙锁：锁定一个范围，不包括记录本身

临键锁：锁定一个范围，包括记录本身

### 悲观锁与乐观锁

**悲观锁**：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完 数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制 

**乐观锁**：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。 

**两种锁的使用场景** 

从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一 种，像**乐观锁适用于写比较少的情况下（多读场景）**，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以**一般多写的场景下用悲观锁就比较合适。**

![一张图彻底搞懂 MySQL 的锁机制](https://cdn.learnku.com/uploads/images/202001/04/32495/Zu4vlv7L2S.png!large)

## MVCC

- undo日志版本链是指一行数据被多个事务依次修改过后，在每个事务修改完后，Mysql会保留修改前的数据undo回滚日志，并且用两个隐藏字段trx_id（事务ID)和roll_pointer(回滚指针）把这些undo日志串联起来形成一个历史记录版本链
- 在**可重复读隔离级别**，当事务开启，执行任何查询sql时会生成当前事务的**一致性视图read-view，**该视图在事务结束之前都不会变化(**如果是读已提交隔离级别在每次执行查询sql时都会重新生成**)，这个视图由执行查询时**所有未提交事务id数组**（数组里最小的id为min_id）和**已创建的最大事务id**（max_id）组成，事务里的任何sql查询结果需要从对应版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。
-  对于删除的情况可以认为是update的特殊情况，会将版本链上最新的数据复制一份，然后将trx_id修改成删除操作的 trx_id，同时在该条记录的头信息（record header）里的（deleted_flag）标记位写上true，来表示当前记录已经被删除，在查询时按照上面的规则查到对应的记录如果delete_flag标记位为true，意味着记录已被删除，则不返回数据
- **版本链比对规则：**
  1. 如果 row 的 trx_id <min_id ，表示这个版本是已提交的事务生成的，这个数据是可见的；
  2. 如果 row 的 trx_id >max_id ，表示这个版本是由将来启动的事务生成的，是不可见的(若 row 的 trx_id 就是当前自己的事务是可见的）；
  3. 如果 row 的 trx_id 落在(min_id <=trx_id<= max_id)，那就包括两种情况 
     - a. 若 row 的 trx_id 在视图数组中，表示这个版本是由还没提交的事务生成的，不可见(若 row 的 trx_id 就是当前自己的事务是可见的)； 
     - 若 row 的 trx_id 不在视图数组中，表示这个版本是已经提交了的事务生成的，可见。

- **Repeatable Read和Read Committed**隔离级别都是基于read view来实现，不同之处在于：

  - Repeatable Read：

    read view是在执行事务中第一条select语句的瞬间创建，后续所有的select都是复用这个对象，所以能保证每次读取的一致性。（**可重复读的语义**）

  - Read Committed：

    事务中每条select语句都会创建read view，这样就可以读取到其它事务已经提交的内容。

![image-20220414105850859](C:\Users\fqh0722\AppData\Roaming\Typora\typora-user-images\image-20220414105850859.png)

## 执行计划

explain的type列，依次从最优到最差分别为：**system > const > eq_ref > ref > range  > index > ALL**

**NULL**:mysql在优化阶段分解查询语句，在执行阶段不用再访问表或索引。例如在索引列中选取最小值，可以单独查找索引来完成，不需要再执行时访问表。

select min(id) from film

**const,system:**const用于主键或唯一索引与常数比较，所以表最多有一个匹配行,system是const的特例，表里只有一条记录。

select * from (select * from film where id = 1)

**eq_ref:**主键索引或唯一索引的所有部分被连接使用，最多只会返回一条符合条件的记录，简单的select查询不会出现这种type。

select * from file_actor left join film on film_actor.film_id = film.id

**ref:**使用普通索引，可能会找到多个符合条件的行

select * from film where name = 'film1'

**range:**范围扫描通常出现在in(), between,>,<,>=等操作中

select * from actor where id > 1;

**index:**扫描某个二级索引

select * from film (有二级索引)

**ALL：**全表扫描

select * from actor(没有二级索引)

## 分库分表

**垂直分表**：将一个拥有10列的表分为两个各自有5列的表，即对数据列的拆分，会改变数据表结构

**水平分表：**将一个拥有10行的表分为两个各自有5行的表，即对数据行的拆分，不会改变表的结构

## binlog与redolog

**binlog:**用于记录数据库执行的写入性操作，主要用于主从复制，主节点将binlog发送给从节点，达到主从一致

**redolog:**redolog包含两个部分，一个是内存中的日志缓冲（redo log buffer),另一个是磁盘上的日志文件（redo log file)。mysql每执行一条DML语句，先将记录写入redo log buffer,后续某个时间点再一次性将多个操作记录写到redo log file,为了保证事务的持久性，当事务提交时，必须先将该事务的所有redolog buffer写入redolog file进行持久化,才能提交成功

**redolog解决问题**

InnoDB存储引擎的存储数据存放在磁盘中，同时提供内存缓存(Buffer Pool)包含磁盘中部分数据页的映射，作为数据库访问的缓冲。Buffer Pool中修改的脏页数据会定期刷新到磁盘中。**如果MySQL宕机，而Buffer Pool的数据没有完全刷新到磁盘，就会导致数据丢失，无法保证持久性。** 因此引入Redo Log解决这个问题。

- 当数据修改时，首先写入Redo Log，再更新到Buffer Pool，保证数据不会因为宕机而丢失，保证持久性。
- 当事务提交时会调用fsync将redo log刷至磁盘持久化。MySQL宕机时，通过读取Redo Log中的数据，对数据库进行恢复。

Redo Log也是记录在磁盘中，为什么会比直接将Buffer Pool写入磁盘更快？

- Buffer Pool刷入脏页至磁盘是随机IO，每次修改的数据位置随机，而Redo Log永远在页中追加，属于顺序IO。
- Buffer Pool刷入磁盘是以数据页为单位，每次都需要整页写入。而Redo Log只需要写入真正**物理修改**的部分，IO数据量大大减少。

![](E:\BaiduNetdiskDownload\图灵学院Java-架构师精品课程（第四期）\一：性能调优专题\23.深入理解MVCC与BufferPool缓存机制-诸葛\Mysql执行过程与BufferPool缓存机制.png)