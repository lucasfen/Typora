## Http三次握手和四次挥手

### TCP报文段首部结构

**序号：**本报文段所发送的数据的第一个字节在整个报文字节流中的序号。

**确认号：**期望收到对方的下一个报文段的数据的第一个字节的序号。 

**URG:**紧急比特 URG,当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送。（一般不使用）

**ACK:**确认比特 ACK,只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。

**PSH:**推送比特 PSH ,当接收 TCP 收到推送比特置 1 的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付。  

**RST:**复位比特 RST (ReSeT) ,当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。

**SYN:** 同步比特 SYN,同步比特 SYN 置为 1，就表示这是一个连接请求或连接接受报文

**FIN:**终止比特 FIN (FINal) , 用来释放一个连接。当FIN = 1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。

![image-20220507175127993](C:\Users\fqh0722\AppData\Roaming\Typora\typora-user-images\image-20220507175127993.png)

### Http的三次握手

1. 第一次客户端向服务端发送连接请求， SYN = 1, seq = x,表示这是一个连接请求，并且报文的初始序号是x,此时客户端进入同步已发送状态（SYN-SENT)
2. 第二次服务端向客户端发回确认报文， SYN = 1, ACK = 1, seq = y, ack = x + 1, 表示服务端的报文的初始序号是y， 确认号是x + 1， 此时服务端进入同步收到状态（SYN-RCVD)
3. 第三次客户端收到确认应答后，向服务端发送确认报文， ACK = 1, seq = x + 1, ack = y + 1,表示客户端的报文的序号是x + 1, 确认号是y + 1， 客户端进入已建立连接状态（ESTABLISHED)
4. 服务端收到客户端的确认报文后也进入已建立连接状态（ESTABLIED)

![image-20220507045014859](C:\Users\fqh0722\AppData\Roaming\Typora\typora-user-images\image-20220507045014859.png)

#### 为什么要三次握手

主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

### Http四次挥手

1. 第一次挥手：客户端向服务端发送关闭连接请求，FIN = 1, seq = x表示这是一个释放连接请求，自己已经没有数据可以发送，但仍然可以接受数据。客户端进入终止等待1状态（FIN-WAIT-1)
2. 第二次挥手：服务端收到客户端的释放连接的请求后，向客户端发送一个确认报文， ACK = 1, ack = x + 1 , 表示自己已经接收到了客户端关闭连接的请求。但还没准备好关闭连接。发送完毕后，服务端进入关闭等待状态（CLOSE-WAIT), 客户端收到服务端的这个确认包后进入终止等待2状态（FIN-WAIT-2)
3. 第三次挥手：服务端准备好关闭连接时，向客户端发送释放连接请求， FIN = 1, ack = x + 1, seq = y, 发送完毕后服务端进入最后确认状态（LAST-ACK)
4. 第四次挥手：客户端收到服务端的关闭连接的请求，向服务端发送一个确认包， ACK = 1, ack = y + 1, seq = x + 1, 客户端进入时间等待状态（TIME-WAIT). 服务端在接收到这个确认包后，关闭连接，进入关闭状态（CLOSE)。客户端在等待了两个最长报文生存时间后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。

![image-20220507045045416](C:\Users\fqh0722\AppData\Roaming\Typora\typora-user-images\image-20220507045045416.png)

#### 为什么最后要等待2MSL

MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。

第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

#### 为什么要四次挥手

因为在接收到客户端的释放连接请求时， 服务端可能还有数据在发送， 因此只能先发送ACK确认报文，告知客户端收到了释放连接请求， 在服务端没有数据发送后， 再向客户端发送FIN释放连接报文。 所以ACK和FIN报文分开发送，导致多了一次。

## 拥塞控制机制

**拥塞窗口：**限制发送方的发送速率

**MSS:**最大报文段长度

**RTT:**往返时间 (表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认，不包含数据传输时间,总共经历的时间)

**ssthresh:**慢启动阈值,当拥塞窗口大小达到阈值时，慢启动结束，TCP转为拥塞避免模式

**慢启动：**当一条TCP连接开始时，拥塞窗口大小为1MSS， 之后每收到一次确认，拥塞窗口就增加1MSS。这样每过一个RTT,拥塞窗口大小就翻倍。所以TCP发送速率起始慢，但在慢启动阶段，发送速率以指数增长。拥塞窗口达到阈值，此时TCP转为拥塞避免模式

**拥塞避免：**每过一个RTT，将拥塞窗口大小 + 1

**超时事件**：发生超时事件，即接受确认超时。此时，将慢启动阈值设为当前拥塞窗口值的一半，将拥塞窗口设为1，TCP转为慢启动模式

**快速重传：**当发送端连续收到3个重复的确认报文端段的时候，tcp就认为拥塞发生了。然后会立即重传丢失的报文段。这就是快速重传的机制

**快速恢复：**当发送端连续收到3个重复的确认报文端段的时候，将慢启动阈值设为当前拥塞窗口值的一半，将拥塞窗口设为新的拥塞窗口值 + 3， TCP转为拥塞避免模式

![image-20220507184905532](C:\Users\fqh0722\AppData\Roaming\Typora\typora-user-images\image-20220507184905532.png)

![image-20220507185754328](C:\Users\fqh0722\AppData\Roaming\Typora\typora-user-images\image-20220507185754328.png)

## TCP和UDP的区别

![image-20220507190831738](C:\Users\fqh0722\AppData\Roaming\Typora\typora-user-images\image-20220507190831738.png)