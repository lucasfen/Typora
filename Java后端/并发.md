# 多线程

## 进程与线程

#### **概念**

进程：进程是代码在数据集合上的一次运行活动,**进程是系统进行资源分配和调度的基本单位**

线程：线程（thread）**被包含在进程之中,是CPU调度和分派的基本单位,**它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行。相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。

#### **区别**

**根本区别**：**进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位**

**资源开销**：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

**包含关系**：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

**内存分配**：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的

**影响关系**：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。

**执行过程**：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行

## 守护线程与用户线程

**用户 (User) 线程**：运行在前台，执行具体的任务，如程序的主线程、连接网 络的子线程等都是用户线程 

**守护 (Daemon) 线程**：运行在后台，为其他前台线程服务。也可以说守护线程是 JVM 中非守护线程的 **“佣人”**。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作 

main 函数所在的线程就是一个用户线程啊，main 函数启动的同时在 JVM 内部同时还启动了好多守护线程，比如**垃圾回收线程**。 

比较明显的区别之一是用户线程结束，JVM 退出，不管这个时候有没有守护线程运行。而**守护线程不会影响 JVM 的退出**。 

**注意事项：** 

1. setDaemon(true)必须在start()方法前执行，否则会抛出IllegalThreadStateException 异常 
2. 在守护线程中产生的新线程也是守护线程 
3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑
4. 守护 (Daemon) 线程中不能依靠 finally 块的内容来确保执行关闭或清理资源的逻辑。因为我们上面也说过了一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作，所以守护 (Daemon) 线程中的 finally 语句块可能无法被执行。 

## 线程死锁的四个条件

1. 互斥，一个资源一次只能被一个线程使用
2. 请求保持，一个线程因请求资源而阻塞时，不释放已拥有的资源
3. 不剥夺，一个线程已拥有的资源，在未释放前，不能强行剥夺
4. 循环等待，多个线程之间循环等待着资源

## 线程的生命周期及五种基本状态

**1. 新建(new)**：新创建了一个线程对象。 

**2. 可运行(runnable)**：线程对象创建后，当调用线程对象的 start()方法，该线程处于就绪状态，等待被线程调度选中，获取cpu的使用权。 

**3. 运行(running)**：可运行状态(runnable)的线程获得了cpu时间片，执行程序代码。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中； 

**4. 阻塞(block)**：处于运行状态中的线程由于某种原因，暂时放弃对 CPU 的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被 CPU 调用以进入到运行状态。 

阻塞的情况分三种：

- 等待阻塞：运行状态中的线程执行 wait()方法，JVM会把该线程放入等待队列(waitting queue)中，使本线程进入到等待阻塞状态； 
- 同步阻塞：线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，则JVM会把该线程放入锁池(lock pool)中，线程会进入同步阻塞状态；
- 其他阻塞: 通过调用线程的 sleep()或 join()或发出了 I/O 请求时，线程会进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O处理完毕时，线程重新转入就绪状态。 

**5. 死亡(dead)**：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。

![image-20220417165541304](C:\Users\fqh0722\AppData\Roaming\Typora\typora-user-images\image-20220417165541304.png)

## 线程同步

#### **概念：**

当一个线程对共享的数据进行操作时，应使之成为一个”原子操作“，即在没有完成相关操作之前，不允许其他线程打断它，否则，就会破坏数据的完整性，必然会得到错误的处理结果，这就是线程的同步。在多线程应用中，考虑不同线程之间的数据同步和防止死锁。当两个或多个线程之间同时等待对方释放资源的时候就会形成线程之间的死锁。为了防止死锁的发生，需要通过同步来实现线程安全。 

**线程互斥**是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。

#### 线程同步的**方法：**

1. **临界区**（Critical section）：通过对多线程的**串行化**来访问公共资源或一段代码，速度快，适合控制数据访问。在任何时候只允许一个线程访问共享资源，如果有多个线程访问，那么当有一个线程进入后，其他试图访问共享资源的线程将会被挂起，并且等到进入临界区的线程离开，临界在被释放后，其他线程才可以抢占。
2.  **互斥量**（Mutex）：为协调对一个共享资源的单独访问而设计。互斥量只有一个，只有拥有互斥量的线程，才有权限去访问系统的公共资源，保证资源不会被多个线程访问。互斥不仅能实现同一个应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。  比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。  
3. **信号量**（Semphore）：为控制一个具有有限数量的用户资源而设计。它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。
4. **事件**(Event)：用来通知线程有一些事件已发生，从而启动后继任务的开始。

## 线程通信

- wait/notify
- volatile

## AQS

### AQS底层

![深入理解Java中的AQS - 夏末秋涼- 博客园](https://img2018.cnblogs.com/blog/1368768/201907/1368768-20190731101705336-2121140493.png)

**AQS中的同步等待队列**：一种基于双向链表数据结构的队列，是FIFO先入先出线程等待队列。通过head和tail记录队首和队尾节点，队列元素类型为Node。

![image-20220421010144932](C:\Users\fqh0722\AppData\Roaming\Typora\typora-user-images\image-20220421010144932.png)

**AQS中的条件等待队列**：一种单向链表队列，通过firstWaiter和lastWaiter记录队首和队尾节点，队列元素类型为Node

![image-20220421010217930](C:\Users\fqh0722\AppData\Roaming\Typora\typora-user-images\image-20220421010217930.png)

**ConditionObject:**AQS的内部类，表示条件变量，每一个条件变量表示一个条件等待队列。其中await()方法类似与wait()方法，signal()类似于notify()方法，signalAll()类似于notifyAll()方法。

**state:**对于ReentrantLock来说，state可以用来表示当前线程获取锁的可重入次数。对于semaphore来说，state可以用来表示当前可用信号的个数。对于CountDownLatch来说，state可以用来表示计数器当前的值

**thread:**存放进入AQS队列里面的线程

**SHARED:**标记该线程是获取共享资源时被阻塞挂起后放入AQS队列

**EXCLUSIVE:**标记该线程是获取独占资源时被阻塞挂起后放入AQS队列

**waitStatus:**记录当前线程等待状态，CANCELLED(线程被取消了)，SIGNAL(线程需要被唤醒)，CONDITION(线程在条件队列中)，PROPAGATE(释放共享资源时需要通知其他节点)。

不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法： 

**isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。

**tryAcquire(int)：**独占方式。尝试获取资源，成功则返回true，失败则返回false。

**tryRelease(int)：**独占方式。尝试释放资源，成功则返回true，失败则返回false。

**tryAcquireShared(int)：**共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 

**tryReleaseShared(int)：**共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。

**AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。**

对于共享资源：与具体线程无关

对于独占资源：

1. 线程调用tryAcquire()方法获取资源，成功则返回，失败则将线程封装为Node，插入AQS等待队列，线程挂起
2. 线程调用tryRelease()方法释放资源，激活AQS等待队列里的一个线程。被激活的线程调用tryAcquire()方法尝试获取资源，若成功，则线程被激活，若失败则被放入AQS等待队列

### AQS-条件变量

1. 线程调用条件变量的await()方法（必须先调用锁的lock方法获取锁），在内部会构造一个Node,将该Node插入条件队列末尾，之后线程释放当前获取的锁，并被挂起
2. 其他线程调用signal()方法（必须先调用锁的lock方法获取锁），在内部会把条件队列里面队首的一个线程节点从条件队列里面移出，放入AQS同步等待队列，这个线程被激活，等待获取锁。

一个锁对应一个AQS同步等待队列，对应多个条件变量，每一个条件变量有自己的一个条件队列

## ReetrantLock

**ReetrantLock是使用AQS实现的可重入独占锁**

- state初始化为0，表示未锁定状态。A线程lock()时， 如果锁当前没有被其他线程占用，并且当前线程之前没有获取过该锁，则当前线程会获取该锁，然后设置当前锁的拥有者是线程A，并且设置AQS的state为1；如果线程A已经获取过该锁，则直接将state+1;如果该锁被其他线程持有，则线程A会被放入AQS同步等待队列后挂起。
- 对于非公平锁，线程在获取锁之前，不会去查看同步等待队列中是否有比自己更早请求该锁的线程，所以后请求锁的线程可能会先活得锁，这里体现了非公平性
- 对于公平锁，线程在获取锁之前，查看同步等待队列中是否有在自己之前的线程节点。

## CountDownLatch

使当前线程等待其他线程执行完任务再执行。任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行 完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子 线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作

## Semaphore

Semaphore 字面意思是信号量的意思，它的作用是控制访问特定资源的线程数目，底层依赖AQS的状态State

## CAS

CAS 是 compare and swap 的缩写，即我们所说的比较交换。CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。 CAS是通过无限循环来获取数据的，若果在第一轮循环中，a 线程获取地址里面的值被b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行。

### CAS问题

- **ABA 问题**： 比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内 存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。
- **循环时间长开销大**： 对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。 
- **只能保证一个共享变量的原子操作：** 当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁

## ThreadLocal

如果一个变量是ThreadLocal变量，那么每一个访问这个变量的线程都会拥有这个变量的一个本地副本

## 线程池

#### 七个参数

corePoolSize, 核心线程池大小。当有新任务时，如果线程池中线程数没有达到线程池的基本大小，则会创建新的线程执行任务，否则将任务放入阻塞队列

maximumPoolSize,最大线程池大小。当阻塞队列填满时，如果线程池中线程数没有超过最大线程数，则会创建新的线程运行任务。否则根据拒绝策略处理新任务

BlockingQueue,等待队列， 存储等待运行的任务

keepAliveTime 非核心线程空闲后，保持存活的时间，此参数只对非核心线程有效

TimeUnit 时间单位

ThreadFactory 每当线程池创建一个新线程时，都是通过线程工厂方法来完成的

RejectedExecutionHandler 当队列和线程池都满了时，根据拒绝策略处理新任务

#### 线程池拒绝策略

1. 默认策略，直接放弃该任务，抛出异常
2. 丢弃策略，放弃该任务，不抛异常
3. 调用者运行策略，由调用线程处理该任务
4. 弃老策略，将等待队列的队首任务丢弃，并执行当前任务

#### 常见的4种阻塞队列 

ArrayBlockingQueue 由数组支持的有界队列 

LinkedBlockingQueue 由链接节点支持的可选有界队列 

PriorityBlockingQueue 由优先级堆支持的无界优先级队列 

DelayQueue 由优先级堆支持的、基于时间的调度队列 

## Java内存模型

Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自 己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成

![image-20220419101217572](C:\Users\fqh0722\AppData\Roaming\Typora\typora-user-images\image-20220419101217572.png)

## 并发编程的可见性，原子性与有序性问题

**原子性**：原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。 

**可见性**：可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。对于串行程序来说，可见性是不存在的，因为我们在任何一个操作中修改了某个变量的值，后续的操作中都能读取这个变量值，并且是修改过的新值。但在多线程环境中可就不一定了，前面我们分析过，由于线程对共享变量的操作都是线程拷贝到各自的工作内存进行操作后才写回到主内存中的，这就可能存在一个线程A修改了 共享变量x的值，还未写回主内存时，另外一个线程B又对主内存中同一个共享变量x进行操作，但此时A线程工作内存中共享变量x对线程B来说并不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题，另外指令重排以及编译器优化也可能导致可见性问题

**有序性**：有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，这样的理解并没有毛病，毕竟对于单线程而言确实如此，但对于多线程环境，则可能出现乱序 现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未必一致，要明白的是，在Java程序中，倘若在本线程内，所有操作都视为有序行为，如果是多线程环境下，一个线程中观察另外一个线程，所有操作都是无序的，前半句指的是单线程内保证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟现象。 

**原子性问题** 

除了JVM自身提供的对基本数据类型读写操作的原子性外，可以通过 **synchronized和 Lock实现原子性**。因为synchronized和Lock能够保证任一时刻只有一个线程访问该代码块。

**可见性问题** 

**volatile关键字**保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值立即被其他的线程看到，即修改的值立即更新到主存中，当其他线程需要读取时，它会去内存中读取新值。**synchronized和Lock也可以保证可见性**，因为它们可以保证任一时刻只有一个 

线程能访问共享资源，并在其释放锁之前将修改的变量刷新到内存中。 

**有序性问题** 

在Java里面，可以通过**volatile关键字**来保证一定的有序性。另外可以通过**synchronized和Lock来保证有序性**，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。 

### 指令重排序

Java内存模型允许编译器和处理器对指令重排序以提高运行性能。即**只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致**，此过程叫指令的重排序。

**as-if-serial语义**：不管怎么重排序（编译器和处理器为了提高并行度），**程序的执行结果不能被改变**。编译器、runtime和处理器都必须遵守as-if-serial语义。为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序， 因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。

**happens-before 原则**： 

1.  程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执 行。
2. 锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是 说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。 
3. volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的 值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的 线程总是能够看到该变量的最新值。 
4. 线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享 变量的修改对线程B可见 
5. 传递性 A先于B ，B先于C 那么A必然先于C 
6.  线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待 当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。 
7. 线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到 中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。 
8. 对象终结规则对象的构造函数执行，结束先于finalize()方法 

## Synchronized

#### synchronized关键字最主要的三种使用方式 

**修饰实例方法:** 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁

**修饰静态方法:** 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，**因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。**

**修饰代码块:** 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 

#### synchronized底层原理

**同步代码块：**synchronized关键字被编译后，会在**同步代码块**的起始位置加上monitorenter指令，在同步代码块的结束位置加上monitorexit指令。

**monitorenter:**任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下： 

**a. 如果monitor的进入数为0**，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者； 

**b. 如果线程已经占有该monitor**，只是重新进入，则进入monitor的进入数加1； 

**c. 如果其他线程已经占用了monitor**，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权； 

**monitorexit**：指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。

**同步方法：**同步方法的常量池中多了 **ACC_SYNCHRONIZED** 标示符。**调用方法时将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置**，如果设置了，**执行线程将先获取** **monitor**，获取成功之后才能执行方法体，**方法执行完后再释放monitor**。在方法执行期间其他任何线程都无法再获得同一个monitor对象。

## Volatile

volatile是Java虚拟机提供的轻量级的同步机制。volatile关键字有如下两个作用 

- 保证被volatile修饰的共享变量对所有线程总数可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总是可以被其他线程立即得知。 
- 禁止指令重排序优化。 

# 锁

## 锁的内存语义

- 当线程释放锁时，Java 内存模型会把该线程对应的本地内存中的共享变量刷新到主内存中
- 当线程获取锁时，Java 内存模型会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量

## Java主流锁

![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png)

## 锁升级

**偏向锁：**在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。如果一个线程获得了锁，那么锁就进入偏向模式，当这个线程再次请求锁时，无需再做任何同步操作，自动获取锁，这样就省去了大量有关锁申请的操作

**轻量级锁：**

- 使用轻量级锁时，不需要申请互斥量。
- JVM会在当前线程的线程栈中开辟一块单独的空间，里面保存指向对象锁Mark Word的指针，同时在对象锁Mark Word中保存指向这片空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败。
- 当锁是轻量级锁，其他线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。
- 轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间申请同一锁的场合，就会导致轻量级锁膨胀为重量级锁

**自旋锁：**线程在抢锁失败后，不阻塞，继续请求锁，这样可以有效减少阻塞/唤醒线程造成的消耗。自旋超过了限定次数，线程会被阻塞

**重量级锁**：当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资。

**锁膨胀升级**：

1. 如果一个线程获得了锁，那么锁进入偏向模式。在锁对象的对象头里面有一个 threadid 字段，线程在第一次申请锁的时候 threadid 将 threadid 设置为其线程 id
2. 再次有线程申请锁的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接获取锁，如果不一致，则升级偏向锁为轻量级锁
3. 线程通过自旋 ，循环一定次数来获取锁，自旋一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁

# 常规

#### Java中获取dump文件

在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java应用的 dump 文件。