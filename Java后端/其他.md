## Resilience4j熔断器

熔断器通过三种正常状态的有限状态机实现：

1. 当熔断器关闭时，所有请求都会通过熔断器
2. 如果失败率超过设定的阈值，熔断器就会从关闭状态转换到打开状态，这时所有的请求都会被拒绝
3. 经过一段时间，熔断器从打开状态转换为半开状态，这时仅有一定数量的请求会通过，并重新计算失败率，如果失败率超过阈值，则变为打开状态，如果失败率低于阈值，则变为关闭状态

redilience4j熔断器使用环形缓冲区来记录请求状态

## 零拷贝

传统文件传输一般是调用read()和write()方法。

期间发生了**4次用户态与内核态的上下文切换**，因为发生了两次系统调用，一次是read(),一次是write(), 每次系统调用都得先从用户态切换到内核态，等内核任务完成，再从内核态切换回用户态。

期间还发生了**4次数据拷贝：**

1. 磁盘文件拷贝到内核缓冲区
2. 内核缓冲区拷贝到用户缓冲区
3. 用户缓冲区拷贝到内核的socket缓冲区
4. 内核socket缓冲区拷贝到网卡缓冲区

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6c3a1a5de3640aeb3b8a8771ff3a810~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

零拷贝使用mmap(),write()来减少数据拷贝，具体过程如下：

- 应用进程调用了 `mmap()` 后，磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；
- 应用进程再调用 `write()`，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；
- 最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，

![img](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/mmap%20+%20write%20%E9%9B%B6%E6%8B%B7%E8%B4%9D.png)

零拷贝也可以使用sendfile()方法，首先，它可以**替代前面的 `read()` 和 `write()` 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销**。

其次，该系统调用，可以直接**把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态**，这样就只有 2 次上下文切换，和 3 次数据拷贝。

![img](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/senfile-3%E6%AC%A1%E6%8B%B7%E8%B4%9D.png)

## 服务限流

### 限流算法

**计数器法：**采用计数器实现限流有点简单粗暴，一般我们会限制一秒钟的能够通过的请求数，比如限流qps为100，算法的实现思路就是从第一个请求进来开始计时，在接下去的1s内，每来一个请求，就把计数加1，如果累加的数字达到了100，那么后续的请求就会被全部拒绝。等到1s结束后，把计数恢复成0，重新开始计数。

具体的实现可以是这样的：对于每次服务调用，可以通过 `AtomicLong#incrementAndGet()`方法来给计数器加1并返回最新值，通过这个最新值和阈值进行比较。

这种实现方式，有一个弊端：如果我在单位时间1s内的前10ms，已经通过了100个请求，那后面的990ms，只能眼巴巴的把请求拒绝，我们把这种现象称为“突刺现象”

**漏桶算法**：算法内部有一个容器，类似生活用到的漏斗，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。不管服务调用方多么不稳定，通过漏桶算法进行限流，每10毫秒处理一次请求。因为处理的速度是固定的，请求进来的速度是未知的，可能突然进来很多请求，没来得及处理的请求就先放在桶里，既然是个桶，肯定是有容量上限，如果桶满了，那么新进来的请求就丢弃。

在算法实现方面，可以准备一个队列，用来保存请求，另外通过一个线程池定期从队列中获取请求并执行，可以一次性获取多个并发执行。这种算法，在使用过后也存在弊端：无法应对短时间的突发流量。

**令牌桶算法：**桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。放令牌这个动作是持续不断的进行，如果桶中令牌数达到上限，就丢弃令牌，所以就存在这种情况，桶中一直有大量的可用令牌，这时进来的请求就可以直接拿到令牌执行，比如设置qps为100，那么限流器初始化完成一秒后，桶中就已经有100个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的100个请求。所以，只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。

具体实现：可以准备一个队列，用来保存令牌，另外通过一个线程池定期生成令牌放到队列中，每来一个请求，就从队列中获取一个令牌，并继续执行。

### 限流器

#### RateLimiter

RateLimiter使用的是令牌桶算法，也就是以固定的频率向桶中放入令牌，例如一秒钟10枚令牌，实际业务在每次响应请求之前都从桶中获取令牌，只有取到令牌的请求才会被成功响应，获取的方式有两种：阻塞等待令牌或者取不到立即返回失败

**RateLimiter方法摘要**

| 修饰符和类型       | 方法和描述                                                   |
| :----------------- | :----------------------------------------------------------- |
| double             | **acquire()** 从RateLimiter获取一个许可，该方法会被阻塞直到获取到请求 |
| double             | **acquire(int permits)**从RateLimiter获取指定许可数，该方法会被阻塞直到获取到请求 |
| static RateLimiter | create(double permitsPerSecond)根据指定的稳定吞吐率创建RateLimiter，这里的吞吐率是指每秒多少许可数（通常是指QPS，每秒多少查询） |
| static RateLimiter | **create(double permitsPerSecond, long warmupPeriod, TimeUnit unit)**根据指定的稳定吞吐率和预热期来创建RateLimiter，这里的吞吐率是指每秒多少许可数（通常是指QPS，每秒多少个请求量），在这段预热时间内，RateLimiter每秒分配的许可数会平稳地增长直到预热期结束时达到其最大速率。（只要存在足够请求数来使其饱和） |
| double             | **getRate()**返回RateLimiter 配置中的稳定速率，该速率单位是每秒多少许可数 |
| void               | **setRate(double permitsPerSecond)**更新RateLimite的稳定速率，参数permitsPerSecond 由构造RateLimiter的工厂方法提供。 |
| String             | toString()返回对象的字符表现形式                             |
| boolean            | **tryAcquire()**从RateLimiter 获取许可，如果该许可可以在无延迟下的情况下立即获取得到的话 |
| boolean            | **tryAcquire(int permits)**从RateLimiter 获取许可数，如果该许可数可以在无延迟下的情况下立即获取得到的话 |
| boolean            | **tryAcquire(int permits, long timeout, TimeUnit unit)**从RateLimiter 获取指定许可数如果该许可数可以在不超过timeout的时间内获取得到的话，或者如果无法在timeout 过期之前获取得到许可数的话，那么立即返回false （无需等待） |
| boolean            | **tryAcquire(long timeout, TimeUnit unit)**从RateLimiter 获取许可如果该许可可以在不超过timeout的时间内获取得到的话，或者如果无法在timeout 过期之前获取得到许可的话，那么立即返回false（无需等待） |

#### semaphore

semaphore维护了一个可设置许可数量的许可集。所有线程在获取许可前会使用 acquire() 方法阻塞当前线程。当获取到可用许可后，开始执行后续逻辑。执行逻辑完成后使用 release() 释放当前线程许可到许可集中，供后续申请者继续使用，此时如果有阻塞的申请者，则会释放一个正在阻塞的申请者开始执行其业务逻辑。

**Semaphore常用方法说明**

```java
acquire()  
获取一个令牌，在获取到令牌、或者被其他线程调用中断之前线程一直处于阻塞状态。

acquire(int permits)  
获取一个令牌，在获取到令牌、或者被其他线程调用中断、或超时之前线程一直处于阻塞状态。
    
acquireUninterruptibly() 
获取一个令牌，在获取到令牌之前线程一直处于阻塞状态（忽略中断）。
    
tryAcquire()
尝试获得令牌，返回获取令牌成功或失败，不阻塞线程。

tryAcquire(long timeout, TimeUnit unit)
尝试获得令牌，在超时时间内循环尝试获取，直到尝试获取成功或超时返回，不阻塞线程。

release()
释放一个令牌，唤醒一个获取令牌不成功的阻塞线程。

hasQueuedThreads()
等待队列里是否还存在等待线程。

getQueueLength()
获取等待队列里阻塞的线程数。

drainPermits()
清空令牌把可用令牌数置为0，返回清空令牌的数量。

availablePermits()
返回可用的令牌数量。
```

#### RateLimiter与Semaphore区别

- RateLimiter通过限制速率来限流；Semaphore通过限制最大并发数来限流