# 知识点

## Redis的应用场景

1. 缓存热点数据，缓解数据库压力
2. 利用redis原子性的自增操作，实现计数器功能，可以用于统计用户点赞数，用户访问数
3. 做为简单的消息队列
4. 做为限速器，限制用户访问接口的频率
5. 利用redis提供的交集，并集，差集等命令，实现好友关系功能

## Redis实现简单的消息队列

1. 使用列表，生产者使用LPUSH命令将任务放入列表，消费者使用RPOP命令从列表中取出任务
2. 使用redis的发布订阅功能
3. 延时队列，使用redis的zset结构，时间戳作为score, 消息内容作为key, 调用zadd生产消息， zrangebyscore获取n秒之前的数据轮询处理

## Redis高性能的原因

1. 基于内存，redis是使用内存存储，没有磁盘IO的开销，数据存在内存中，读写速度快
2. 单线程实现，redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销
3. IO多路复用模型，redis采用IO多路复用技术，单线程监听多个IO流，空闲时，会将当前线程阻塞，当有一个或多个IO流有事件时，就从阻塞状态唤醒，轮询一遍所有有事件的流，依次处理。
4. 高效的数据结构

## Redis线程模型

Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。

- 文件事件处理器使用I/O多路复用(multiplexing)程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。
- 当被监听的套接字准备好执行连接应答(accept)、读取(read)、写入(write)、关闭(close)等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。

![img](https://filescdn.proginn.com/86ffc8d5b58ad887e0f0dc2acee2067e/e2d6106091842a670d8e0e9933c1569f.webp)

## Redis主从复制

1. 从节点向主节点发送同步命令“psync"
2. 如果从节点初次连接到主节点，会触发一次全量复制， 主节点开启一个后台线程，生成一份RDB快照文件，同时将新收到的写命令下入缓存
3. 主节点将RDB文件发给从节点，并且将缓存的新收到的写命令发给从节点

## Redis哨兵

由一个或多个哨兵实例组成哨兵系统，可以监视任意多个主从服务器，并在被监视的主服务器下线时，自动将下线主服务器下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求

### 哨兵leader选举

1. 当一个哨兵发现主服务器下线时，会向其他哨兵发送请求，要求其他哨兵将自己设为leader
2. 最先向目标哨兵发送请求的源哨兵将成为目标哨兵的leader,同时拒绝其他哨兵的请求
3. 如果某一个哨兵被半数以上的哨兵设为leader,那么这个哨兵则成为leader
4. 如果在一个选举周期内没有一个哨兵活得半数以上的支持，那么各个哨兵将在一段时间后再次进行选举，直到选出leader

## Redis集群

Redis Cluster并没有使用一致性hash，而是采用slot(槽)的概念，一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行 

**槽位定位算法** 

Cluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行取模 来得到具体槽位。 

HASH_SLOT = CRC16(key) mod 16384

## Redis持久化

### RDB

RDB持久化通过保存数据库中的键值对来记录数据库状态

**优点：**

1. 容灾性好，一个文件可以保存到安全的磁盘
2. 相对于数据集大时，比AOF的启动效率更高

**缺点：**

1. 数据安全性能低，RDB隔一段时间进行持久化，如果持久化之间发生故障，会丢失数据

### AOF

AOF持久化通过保存redis服务器所执行的写命令来记录数据库状态

1. 服务器在执行完一个写命令后，会将写命令追加到服务器上的一个缓冲区中
2. 根据配置，将缓冲区中内容写入AOF文件

#### AOF同步的三种配置

1. always,缓冲区有更新就立即同步到AOF文件
2. everysec，缓冲区有更新，且距离上次同步超过一秒，则同步到AOF文件
3. no, 何时同步由操作系统决定

**AOF优点**

1. 数据安全

**AOF缺点**

1. AOF文件比RDB文件大，恢复速度慢
2. 数据集大时，比rdb启动效率低

## Redis过期键删除策略

1. 惰性过期：使用时检查是否过期
2. 定时过期：给每一个key设置定时器，到期立即清除
3. 定期过期：每过一段时间扫描一定数量的key, 清除其中过期的key

## Redis内存淘汰策略

**全局键空间选择性移除**

1. 当内存不足以容纳新写入数据时，直接报错
2. 当内存不足以容纳新写入数据时，移除最近最少使用的key
3. 当内存不足以容纳新写入的数据时，随机移除key

**设置了过期时间的见空间选择性移除**

1. 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key
2. 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除key
3. 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除

## 事务

Redis的事务保证隔离性，不保证原子性

## Redis数据结构

**SDS(简单动态字符串)**

```c++
struct sdshdr {
    unsigned int len; //buf 中已占字节数，len 的长度不包括 \0
    unsigned int free; //buf 中剩余空闲字节数
    char buf[]; //一个 char 类型的字符数组，用于存储实际字符串的内容，以 \0 结尾，可以使用 C 语言中现成的库函数
};

```

**优点：**

- 使用 `len` 来存储字符数组长度，因此获取字符串长度的时间复杂度为 **O(1)** （C 语言中获取字符串长度的时间复杂度为 O(N)。）
- 使用 `free` 来存储未使用的字节，来**避免频繁的内存分配，减少耗时**。

#### zset

#### bitmap

## Redisson分布式锁

```java
private Redisson redisson;
Rlock lock = redisson.getLock(lockKey);
//通过lua脚本在redis中添加key-value并设置过期时间，带上线程ID
//hset lockKey threadId 1
//pexpire lockKey leaseTime
//开启定时任务，每过三分之一的过期时间，执行定时任务，进行锁续命
//其他线程自旋等待锁
//Rlock是可重入锁
lock.lock();
lock.unlock();
```



## 缓存雪崩

**概念**：同一时间，大量key失效

**解决方法：**给key的过期时间加上随机值，防止同一时间大量数据过期

## 缓存穿透

**概念：**缓存和数据库中都没有数据，大量请求直接请求数据库

**解决方法：**

1. 接口增加校验
2. 如果在缓存和数据库中都没有取到，可以在缓存中添加key-null
3. 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截，避免请求落到数据库

## 缓存击穿

**概念：**缓存中没有热点数据，数据库中有，和缓存雪崩不同，缓存击穿是指并发查同一条数据，缓存雪崩是不同数据都过期了。

**解决方法：**

1. 设置热点数据永不过期
2. 加互斥锁

## 布隆过滤器

布隆过滤器就是**一个大型的位数组和几个不一样的无偏 hash 函数**。所谓无偏就是能够把元素的 hash 值算得比较均匀。 

向布隆过滤器中添加 key 时，会使用多个 hash 函数对 key 进行 hash 算得一个整数索引值然后对位数组长度进行取模运算得到一个位置，每个hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就 完成了 add 操作。 

向布隆过滤器询问 key 是否存在时，跟 add 一样，也会把 hash 的几个位置都算出来，看看位数组中这几个位置是否都为 1，只要有一个位为 0，那么说明布隆过滤器中这个key 不存在。如果都是 1，这并不能说明这个key 就一定存在，只是极有可能存在，因为这些位被置为 1 可能是因为其它的 key 存在所致。如果这个位数组 比较稀疏，这个概率就会很大，如果这个位数组比较拥挤，这个概率就会降低。

**当布隆过滤器说某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在**

优点：查询效率高，空间效率高

缺点：有一定错误识别率

## 缓存与数据库双写不一致

**解决方案：** 

1、对于并发几率很小的数据(如个人维度的订单数据、用户数据等)，这种几乎不用考虑这个问题，很少会发生 缓存不一致，可以给缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。 

2、就算并发很高，如果业务上能容忍短时间的缓存数据不一致(如商品名称，商品分类菜单等)，缓存加上过期时间依然可以解决大部分业务对于缓存的要求。 

3、如果不能容忍缓存数据不一致，可以通过加**读写锁**保证并发读写或写写的时候按顺序排好队，**读读的时候相当于无锁**。 

